---
alwaysApply: true
---
<frontend-testing-pyramid-guidelines>
=== foundation rules ===

# Frontend Testing Pyramid Guidelines

This frontend follows the Testing Pyramid strategy using Playwright for API/E2E tests. The pyramid emphasizes writing focused E2E tests that verify complete API workflows and critical user journeys from the frontend perspective.

## Testing Pyramid Structure

```
        /\
       /  \     E2E/API Tests (100%)
      /    \    - Test full API workflows
     /------\   - Test authentication flows
    /        \  - Test critical user journeys
   /----------\ - Verify API contracts
  /            \ 
 /--------------\ 
```

**Note**: Currently, this frontend focuses on API/E2E tests using Playwright. Component-level unit tests may be added in the future.

## Test Types

### API/E2E Tests (100%)
**Location**: `tests/api/scenarios/`

API/E2E tests verify complete workflows from the frontend perspective, testing the full stack integration.

**When to write API/E2E tests:**
- Testing complete user workflows
- Testing authentication and authorization flows
- Testing API endpoints and contracts
- Testing critical business processes
- Validating frontend-backend integration
- Testing error handling and edge cases

**Characteristics:**
- Slower execution (> 1s per test)
- Tests real API endpoints
- Uses Playwright fixtures
- Tests full request/response cycles
- Verifies complete user journeys

**Example:**
<code-snippet name="API Test Example" lang="typescript">
import { test, expect, testUser } from '../../fixtures';
import {
  expectSuccess,
  expectValidUser,
  expectValidationErrors,
} from '../../features/shared/helpers/test-helpers';

test.describe('Login', { tag: ['@api', '@auth', '@login'] }, () => {
  test('should login with valid credentials', async ({ authClient }) => {
    // Arrange & Act
    const response = await authClient.login(testUser.email, testUser.password);

    // Assert
    expectSuccess(response);
    await expectValidUser(response);
  });

  test('should not login with invalid credentials', async ({ authClient }) => {
    // Arrange & Act
    const response = await authClient.login('invalid@example.com', 'wrong');

    // Assert
    await expectValidationErrors(response);
  });
});
</code-snippet>

## Test Organization

### Directory Structure
```
tests/api/
├── features/              # All code organized by feature
│   ├── auth/             # Authentication feature code
│   │   ├── auth-client.ts
│   │   └── fixtures.ts
│   ├── health/           # Health check feature code
│   │   └── health-client.ts
│   └── shared/           # Shared utilities
│       ├── core/         # BaseClient, ApiClient
│       ├── handlers/     # CSRF, error, request handlers
│       ├── helpers/      # Test helper functions
│       ├── types/        # Type definitions
│       └── factories/    # Client factories
├── scenarios/            # All test files organized by feature
│   ├── auth/
│   │   ├── login.spec.ts
│   │   ├── logout.spec.ts
│   │   └── user.spec.ts
│   └── health/
│       └── health.spec.ts
└── fixtures/             # Playwright fixtures and test data
    ├── api.ts           # Playwright test fixtures
    ├── index.ts         # Main fixtures entry point
    └── data/            # Test data fixtures
        ├── user.ts
        └── index.ts
```

### Feature-Based Organization
- **Code**: Organized in `features/{feature}/`
- **Tests**: Organized in `scenarios/{feature}/`
- **Shared**: Utilities in `features/shared/`
- **Fixtures**: Test data in `fixtures/`

### Naming Conventions
- Test files: `{feature}.spec.ts` (e.g., `login.spec.ts`)
- Client files: `{feature}-client.ts` (e.g., `auth-client.ts`)
- Use descriptive test names: `should [expected behavior] when [condition]`

## Running Tests

### Run All API Tests
```bash
pnpm test:api
```

### Run with UI
```bash
pnpm test:api:ui
```

### Run in Debug Mode
```bash
pnpm test:api:debug
```

### Run Specific Feature
```bash
pnpm test:api scenarios/auth
```

### Run Specific Test File
```bash
pnpm test:api scenarios/auth/login.spec.ts
```

## Playwright Fixtures

### Using Fixtures
Fixtures provide automatic setup/teardown and composability:

<code-snippet name="Fixture Usage" lang="typescript">
import { test } from '../../fixtures';

test('should get authenticated user', async ({ authenticatedAuthClient }) => {
  // authenticatedAuthClient is already logged in
  const userResponse = await authenticatedAuthClient.getUser();
  await expectValidUser(userResponse);
});
</code-snippet>

### Available Fixtures
- `authClient`: Unauthenticated AuthClient instance
- `healthClient`: HealthClient instance
- `apiClient`: Unified ApiClient facade
- `authenticatedAuthClient`: Pre-authenticated AuthClient (automatically logs in)

### Creating Custom Fixtures
<code-snippet name="Custom Fixture" lang="typescript">
// fixtures/api.ts
export const test = base.extend<ApiFixtures>({
  productsClient: async ({ request }, use) => {
    const productsClient = new ProductsClient(request);
    await use(productsClient);
  },
  
  authenticatedProductsClient: async ({ authenticatedAuthClient, request }, use) => {
    const productsClient = new ProductsClient(request);
    await use(productsClient);
  },
});
</code-snippet>

## BaseClient Pattern

All API clients extend `BaseClient` for consistent behavior:

<code-snippet name="BaseClient Usage" lang="typescript">
import { BaseClient } from '../shared/core/base-client';

export class ProductsClient extends BaseClient {
  async getAll(): Promise<APIResponse> {
    return this.get('/api/products');
  }
  
  async create(data: Partial<Product>): Promise<APIResponse> {
    await this.ensureCsrfCookie();
    return this.post('/api/products', data);
  }
}
</code-snippet>

### BaseClient Methods
- `get(endpoint, options?)` - GET request
- `post(endpoint, data, options?)` - POST request
- `put(endpoint, data, options?)` - PUT request
- `patch(endpoint, data, options?)` - PATCH request
- `delete(endpoint, options?)` - DELETE request
- `ensureCsrfCookie()` - Ensures CSRF cookie is obtained

## Test Helper Functions

Use helper functions for common assertions:

<code-snippet name="Helper Functions" lang="typescript">
import {
  expectSuccess,
  expectStatus,
  expectError,
  expectValidUser,
  expectValidationErrors,
  expectUnauthenticated,
  expectCookiesSet,
} from '../../features/shared/helpers/test-helpers';

// Assert 2xx status
expectSuccess(response);

// Assert specific status code
expectStatus(response, 201);

// Assert error status
expectError(response, 422);

// Assert valid user object
await expectValidUser(response);

// Assert validation errors
await expectValidationErrors(response);

// Assert unauthenticated
expectUnauthenticated(response);

// Assert cookies are present
expectCookiesSet(response);
</code-snippet>

## AAA Pattern (Arrange-Act-Assert)

All tests follow the AAA pattern for clarity:

<code-snippet name="AAA Pattern" lang="typescript">
test('should create product', async ({ authenticatedProductsClient }) => {
  // Arrange
  const productData = {
    name: 'Test Product',
    description: 'Test Description',
    price: 99.99,
  };
  
  // Act
  const response = await authenticatedProductsClient.create(productData);
  
  // Assert
  expectStatus(response, 201);
});
</code-snippet>

## Test Best Practices

### 1. Test Critical Paths
- Focus on important user journeys
- Test authentication flows
- Test core business processes
- Test error handling

### 2. Use Descriptive Test Names
- Use format: `should [expected behavior] when [condition]`
- Make test purpose clear from the name
- Group related tests with `test.describe()`

### 3. Keep Tests Independent
- Each test should be independent
- No shared state between tests
- Use fixtures for setup/teardown

### 4. Use Tags for Organization
<code-snippet name="Test Tags" lang="typescript">
test.describe('Login', { tag: ['@api', '@auth', '@login'] }, () => {
  // Tests here
});
</code-snippet>

### 5. Test All Scenarios
- Happy paths (successful scenarios)
- Failure paths (error scenarios)
- Edge cases (boundary conditions)
- Validation errors

### 6. Use TypeScript for Type Safety
- Leverage TypeScript for type checking
- Use typed responses when possible
- Define interfaces for test data

## Common Patterns

### Testing Authentication
<code-snippet name="Authentication Test" lang="typescript">
test('should login with valid credentials', async ({ authClient }) => {
  const response = await authClient.login(testUser.email, testUser.password);
  
  expectSuccess(response);
  await expectValidUser(response);
  expectCookiesSet(response);
});

test('should not login with invalid credentials', async ({ authClient }) => {
  const response = await authClient.login('invalid@example.com', 'wrong');
  
  await expectValidationErrors(response);
});
</code-snippet>

### Testing Protected Routes
<code-snippet name="Protected Route Test" lang="typescript">
test('should access protected route when authenticated', async ({ authenticatedAuthClient }) => {
  const response = await authenticatedAuthClient.getUser();
  
  expectSuccess(response);
  await expectValidUser(response);
});

test('should not access protected route when not authenticated', async ({ authClient }) => {
  // Note: This would require a separate endpoint or different client
  // Implementation depends on your API structure
});
</code-snippet>

### Testing CRUD Operations
<code-snippet name="CRUD Test" lang="typescript">
test.describe('Products CRUD', () => {
  test('should create product', async ({ authenticatedProductsClient }) => {
    const response = await authenticatedProductsClient.create({
      name: 'Test Product',
      price: 99.99,
    });
    
    expectStatus(response, 201);
  });
  
  test('should get all products', async ({ authenticatedProductsClient }) => {
    const response = await authenticatedProductsClient.getAll();
    
    expectSuccess(response);
  });
  
  test('should update product', async ({ authenticatedProductsClient }) => {
    // First create a product, then update it
    const createResponse = await authenticatedProductsClient.create({
      name: 'Test Product',
      price: 99.99,
    });
    const product = await createResponse.json();
    
    const updateResponse = await authenticatedProductsClient.update(product.id, {
      name: 'Updated Product',
    });
    
    expectSuccess(updateResponse);
  });
});
</code-snippet>

## Adding New Features

When adding a new feature:

1. **Create feature code folder**: `features/{feature-name}/`
2. **Create client**: `features/{feature-name}/{feature}-client.ts` (extends BaseClient)
3. **Add to factory** (optional): Update `features/shared/factories/client-factory.ts`
4. **Create fixtures** (if needed): Add to `fixtures/api.ts`
5. **Create test folder**: `scenarios/{feature-name}/`
6. **Create tests**: `scenarios/{feature-name}/{feature}.spec.ts`

See `tests/api/SCALABILITY.md` for detailed guide.

## Test Coverage Goals

- **API/E2E Tests**: Cover all critical user journeys
- **Authentication**: Test all auth flows
- **API Contracts**: Verify all API endpoints work correctly
- **Error Handling**: Test error scenarios and edge cases

## References

- Root testing pyramid: `.cursor/rules/testing-pyramid.mdc`
- Test organization: `tests/api/README.md`
- Scalability guide: `tests/api/SCALABILITY.md`
- Playwright documentation: https://playwright.dev
</frontend-testing-pyramid-guidelines>
