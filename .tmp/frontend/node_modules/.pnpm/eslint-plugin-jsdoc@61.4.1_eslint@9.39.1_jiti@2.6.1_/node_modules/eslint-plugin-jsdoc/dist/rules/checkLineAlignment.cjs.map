{"version":3,"file":"checkLineAlignment.cjs","names":["_alignTransform","_interopRequireDefault","require","_iterateJsdoc","_commentParser","e","__esModule","default","flow","commentFlow","transforms","startsWithListMarker","text","isFirstLineOfTag","test","shouldAllowExtraIndent","tag","idx","hasSeenListMarker","lineIdx","line","source","isFirstLine","tokens","description","checkNotAlignedPerTag","utils","customSpacings","spacerProps","contentProps","mightHaveNamepath","tagMightHaveNameOrNamepath","followedBySpace","callbck","nextIndex","slice","some","spacerProp","innerIdx","contentProp","spacePropVal","ret","postHyphenSpacing","postHyphen","exactHyphenSpacing","RegExp","hasNoHyphen","hasExactHyphenSpacing","ok","contentPropVal","spacerPropVal","spacing","length","fix","entries","padStart","hasSpace","contentPrp","hyphenSpacing","replace","setTag","reportJSDoc","checkAlignment","disableWrapIndent","indent","jsdoc","jsdocNode","preserveMainDescriptionPostDelimiter","report","tags","wrapIndent","transform","alignTransform","transformedJsdoc","comment","value","formatted","stringify","trimStart","fixer","replaceText","_default","exports","iterateJsdoc","context","applicableTags","options","includes","foundTags","getPresentTags","type","name","actualIndent","postDelimiter","hasCorrectWrapIndent","hasExtraIndent","startsWith","isInListContext","number","charAt","iterateAllJsdocs","meta","docs","url","fixable","schema","enum","additionalProperties","properties","postName","postTag","postType","items","module"],"sources":["../../src/rules/checkLineAlignment.js"],"sourcesContent":["import alignTransform from '../alignTransform.js';\nimport iterateJsdoc from '../iterateJsdoc.js';\nimport {\n  transforms,\n} from 'comment-parser';\n\nconst {\n  flow: commentFlow,\n} = transforms;\n\n/**\n * Detects if a line starts with a markdown list marker\n * Supports: -, *, numbered lists (1., 2., etc.)\n * This explicitly excludes hyphens that are part of JSDoc tag syntax\n * @param {string} text - The text to check\n * @param {boolean} isFirstLineOfTag - True if this is the first line (tag line)\n * @returns {boolean} - True if the text starts with a list marker\n */\nconst startsWithListMarker = (text, isFirstLineOfTag = false) => {\n  // On the first line of a tag, the hyphen is typically the JSDoc separator,\n  // not a list marker\n  if (isFirstLineOfTag) {\n    return false;\n  }\n\n  // Match lines that start with optional whitespace, then a list marker\n  // - or * followed by a space\n  // or a number followed by . or ) and a space\n  return /^\\s*(?:[\\-*]|\\d+(?:\\.|\\)))\\s+/v.test(text);\n};\n\n/**\n * Checks if we should allow extra indentation beyond wrapIndent.\n * This is true for list continuation lines (lines with more indent than wrapIndent\n * that follow a list item).\n * @param {import('comment-parser').Spec} tag - The tag being checked\n * @param {import('../iterateJsdoc.js').Integer} idx - Current line index (0-based in tag.source.slice(1))\n * @returns {boolean} - True if extra indentation should be allowed\n */\nconst shouldAllowExtraIndent = (tag, idx) => {\n  // Check if any previous line in this tag had a list marker\n  // idx is 0-based in the continuation lines (tag.source.slice(1))\n  // So tag.source[0] is the tag line, tag.source[idx+1] is current line\n  let hasSeenListMarker = false;\n\n  // Check all lines from the tag line onwards\n  for (let lineIdx = 0; lineIdx <= idx + 1; lineIdx++) {\n    const line = tag.source[lineIdx];\n    const isFirstLine = lineIdx === 0;\n    if (line?.tokens?.description && startsWithListMarker(line.tokens.description, isFirstLine)) {\n      hasSeenListMarker = true;\n      break;\n    }\n  }\n\n  return hasSeenListMarker;\n};\n\n/**\n * @typedef {{\n *   postDelimiter: import('../iterateJsdoc.js').Integer,\n *   postHyphen: import('../iterateJsdoc.js').Integer,\n *   postName: import('../iterateJsdoc.js').Integer,\n *   postTag: import('../iterateJsdoc.js').Integer,\n *   postType: import('../iterateJsdoc.js').Integer,\n * }} CustomSpacings\n */\n\n/**\n * @param {import('../iterateJsdoc.js').Utils} utils\n * @param {import('comment-parser').Spec & {\n *   line: import('../iterateJsdoc.js').Integer\n * }} tag\n * @param {CustomSpacings} customSpacings\n */\nconst checkNotAlignedPerTag = (utils, tag, customSpacings) => {\n  /*\n  start +\n  delimiter +\n  postDelimiter +\n  tag +\n  postTag +\n  type +\n  postType +\n  name +\n  postName +\n  description +\n  end +\n  lineEnd\n   */\n\n  /**\n   * @typedef {\"tag\"|\"type\"|\"name\"|\"description\"} ContentProp\n   */\n\n  /** @type {(\"postDelimiter\"|\"postTag\"|\"postType\"|\"postName\")[]} */\n  let spacerProps;\n  /** @type {ContentProp[]} */\n  let contentProps;\n  const mightHaveNamepath = utils.tagMightHaveNameOrNamepath(tag.tag);\n  if (mightHaveNamepath) {\n    spacerProps = [\n      'postDelimiter', 'postTag', 'postType', 'postName',\n    ];\n    contentProps = [\n      'tag', 'type', 'name', 'description',\n    ];\n  } else {\n    spacerProps = [\n      'postDelimiter', 'postTag', 'postType',\n    ];\n    contentProps = [\n      'tag', 'type', 'description',\n    ];\n  }\n\n  const {\n    tokens,\n  } = tag.source[0];\n\n  /**\n   * @param {import('../iterateJsdoc.js').Integer} idx\n   * @param {(notRet: boolean, contentProp: ContentProp) => void} [callbck]\n   */\n  const followedBySpace = (idx, callbck) => {\n    const nextIndex = idx + 1;\n\n    return spacerProps.slice(nextIndex).some((spacerProp, innerIdx) => {\n      const contentProp = contentProps[nextIndex + innerIdx];\n\n      const spacePropVal = tokens[spacerProp];\n\n      const ret = spacePropVal;\n\n      if (callbck) {\n        callbck(!ret, contentProp);\n      }\n\n      return ret && (callbck || !contentProp);\n    });\n  };\n\n  const postHyphenSpacing = customSpacings?.postHyphen ?? 1;\n  const exactHyphenSpacing = new RegExp(`^\\\\s*-\\\\s{${postHyphenSpacing},${postHyphenSpacing}}(?!\\\\s)`, 'v');\n  const hasNoHyphen = !(/^\\s*-(?!$)(?=\\s)/v).test(tokens.description);\n  const hasExactHyphenSpacing = exactHyphenSpacing.test(\n    tokens.description,\n  );\n\n  // If checking alignment on multiple lines, need to check other `source`\n  //   items\n  // Go through `post*` spacing properties and exit to indicate problem if\n  //   extra spacing detected\n  const ok = !spacerProps.some((spacerProp, idx) => {\n    const contentProp = contentProps[idx];\n    const contentPropVal = tokens[contentProp];\n    const spacerPropVal = tokens[spacerProp];\n    const spacing = customSpacings?.[spacerProp] || 1;\n\n    // There will be extra alignment if...\n\n    // 1. The spaces don't match the space it should have (1 or custom spacing) OR\n    return spacerPropVal.length !== spacing && spacerPropVal.length !== 0 ||\n\n      // 2. There is a (single) space, no immediate content, and yet another\n      //     space is found subsequently (not separated by intervening content)\n      spacerPropVal && !contentPropVal && followedBySpace(idx);\n  }) && (hasNoHyphen || hasExactHyphenSpacing);\n  if (ok) {\n    return;\n  }\n\n  const fix = () => {\n    for (const [\n      idx,\n      spacerProp,\n    ] of spacerProps.entries()) {\n      const contentProp = contentProps[idx];\n      const contentPropVal = tokens[contentProp];\n\n      if (contentPropVal) {\n        const spacing = customSpacings?.[spacerProp] || 1;\n        tokens[spacerProp] = ''.padStart(spacing, ' ');\n        followedBySpace(idx, (hasSpace, contentPrp) => {\n          if (hasSpace) {\n            tokens[contentPrp] = '';\n          }\n        });\n      } else {\n        tokens[spacerProp] = '';\n      }\n    }\n\n    if (!hasExactHyphenSpacing) {\n      const hyphenSpacing = /^\\s*-\\s+/v;\n      tokens.description = tokens.description.replace(\n        hyphenSpacing, '-' + ''.padStart(postHyphenSpacing, ' '),\n      );\n    }\n\n    utils.setTag(tag, tokens);\n  };\n\n  utils.reportJSDoc('Expected JSDoc block lines to not be aligned.', tag, fix, true);\n};\n\n/**\n * @param {object} cfg\n * @param {CustomSpacings} cfg.customSpacings\n * @param {string} cfg.indent\n * @param {import('comment-parser').Block} cfg.jsdoc\n * @param {import('eslint').Rule.Node & {\n *   range: [number, number]\n * }} cfg.jsdocNode\n * @param {boolean} cfg.preserveMainDescriptionPostDelimiter\n * @param {import('../iterateJsdoc.js').Report} cfg.report\n * @param {string[]} cfg.tags\n * @param {import('../iterateJsdoc.js').Utils} cfg.utils\n * @param {string} cfg.wrapIndent\n * @param {boolean} cfg.disableWrapIndent\n * @returns {void}\n */\nconst checkAlignment = ({\n  customSpacings,\n  disableWrapIndent,\n  indent,\n  jsdoc,\n  jsdocNode,\n  preserveMainDescriptionPostDelimiter,\n  report,\n  tags,\n  utils,\n  wrapIndent,\n}) => {\n  const transform = commentFlow(\n    alignTransform({\n      customSpacings,\n      disableWrapIndent,\n      indent,\n      preserveMainDescriptionPostDelimiter,\n      tags,\n      wrapIndent,\n    }),\n  );\n  const transformedJsdoc = transform(jsdoc);\n\n  const comment = '/*' +\n  /**\n   * @type {import('eslint').Rule.Node & {\n   *   range: [number, number], value: string\n   * }}\n   */ (jsdocNode).value + '*/';\n\n  const formatted = utils.stringify(transformedJsdoc)\n    .trimStart();\n\n  if (comment !== formatted) {\n    report(\n      'Expected JSDoc block lines to be aligned.',\n      /** @type {import('eslint').Rule.ReportFixer} */ (fixer) => {\n        return fixer.replaceText(jsdocNode, formatted);\n      },\n    );\n  }\n};\n\nexport default iterateJsdoc(({\n  context,\n  indent,\n  jsdoc,\n  jsdocNode,\n  report,\n  utils,\n}) => {\n  const {\n    customSpacings,\n    disableWrapIndent = false,\n    preserveMainDescriptionPostDelimiter,\n    tags: applicableTags = [\n      'param', 'arg', 'argument', 'property', 'prop', 'returns', 'return', 'template',\n    ],\n    wrapIndent = '',\n  } = context.options[1] || {};\n\n  if (context.options[0] === 'always') {\n    // Skip if it contains only a single line.\n    if (!(\n      /**\n       * @type {import('eslint').Rule.Node & {\n       *   range: [number, number], value: string\n       * }}\n       */\n      (jsdocNode).value.includes('\\n')\n    )) {\n      return;\n    }\n\n    checkAlignment({\n      customSpacings,\n      disableWrapIndent,\n      indent,\n      jsdoc,\n      jsdocNode,\n      preserveMainDescriptionPostDelimiter,\n      report,\n      tags: applicableTags,\n      utils,\n      wrapIndent,\n    });\n\n    return;\n  }\n\n  const foundTags = utils.getPresentTags(applicableTags);\n  if (context.options[0] !== 'any') {\n    for (const tag of foundTags) {\n      checkNotAlignedPerTag(\n        utils,\n        /**\n         * @type {import('comment-parser').Spec & {\n         *   line: import('../iterateJsdoc.js').Integer\n         * }}\n         */\n        (tag),\n        customSpacings,\n      );\n    }\n  }\n\n  for (const tag of foundTags) {\n    if (tag.source.length > 1) {\n      let idx = 0;\n      for (const {\n        tokens,\n      // Avoid the tag line\n      } of tag.source.slice(1)) {\n        idx++;\n\n        if (\n          !tokens.description ||\n          // Avoid first lines after multiline type\n          tokens.type ||\n          tokens.name\n        ) {\n          continue;\n        }\n\n        // Don't include a single separating space/tab\n        const actualIndent = tokens.postDelimiter.slice(1);\n        const hasCorrectWrapIndent = actualIndent === wrapIndent;\n\n        // Allow extra indentation if this line or previous lines contain list markers\n        // This preserves nested list structure\n        const hasExtraIndent = actualIndent.length > wrapIndent.length &&\n                                actualIndent.startsWith(wrapIndent);\n        const isInListContext = shouldAllowExtraIndent(tag, idx - 1);\n\n        if (!disableWrapIndent && !hasCorrectWrapIndent &&\n            !(hasExtraIndent && isInListContext)) {\n          utils.reportJSDoc('Expected wrap indent', {\n            line: tag.source[0].number + idx,\n          }, () => {\n            tokens.postDelimiter = tokens.postDelimiter.charAt(0) + wrapIndent;\n          });\n          return;\n        }\n      }\n    }\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid alignment of JSDoc block lines.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/check-line-alignment.md#repos-sticky-header',\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        description: `If the string value is\n\\`\"always\"\\` then a problem is raised when the lines are not aligned.\nIf it is \\`\"never\"\\` then a problem should be raised when there is more than\none space between each line's parts. If it is \\`\"any\"\\`, no alignment is made.\nDefaults to \\`\"never\"\\`.\n\nNote that in addition to alignment, the \"never\" and \"always\" options will both\nensure that at least one space is present after the asterisk delimiter.`,\n        enum: [\n          'always', 'never', 'any',\n        ],\n        type: 'string',\n      },\n      {\n        additionalProperties: false,\n        properties: {\n          customSpacings: {\n            additionalProperties: false,\n            description: `An object with any of the following spacing keys set to an integer.\nIf a spacing is not defined, it defaults to one.`,\n            properties: {\n              postDelimiter: {\n                description: 'Affects spacing after the asterisk (e.g., `*   @param`)',\n                type: 'integer',\n              },\n              postHyphen: {\n                description: 'Affects spacing after any hyphens in the description (e.g., `* @param {someType} name -  A description`)',\n                type: 'integer',\n              },\n              postName: {\n                description: 'Affects spacing after the name (e.g., `* @param {someType} name   `)',\n                type: 'integer',\n              },\n              postTag: {\n                description: 'Affects spacing after the tag (e.g., `* @param  `)',\n                type: 'integer',\n              },\n              postType: {\n                description: 'Affects spacing after the type (e.g., `* @param {someType}   `)',\n                type: 'integer',\n              },\n            },\n            type: 'object',\n          },\n          disableWrapIndent: {\n            description: 'Disables `wrapIndent`; existing wrap indentation is preserved without changes.',\n            type: 'boolean',\n          },\n          preserveMainDescriptionPostDelimiter: {\n            default: false,\n            description: `A boolean to determine whether to preserve the post-delimiter spacing of the\nmain description. If \\`false\\` or unset, will be set to a single space.`,\n            type: 'boolean',\n          },\n          tags: {\n            description: `Use this to change the tags which are sought for alignment changes. Defaults to an array of\n\\`['param', 'arg', 'argument', 'property', 'prop', 'returns', 'return', 'template']\\`.`,\n            items: {\n              type: 'string',\n            },\n            type: 'array',\n          },\n          wrapIndent: {\n            description: `The indent that will be applied for tag text after the first line.\nDefault to the empty string (no indent).`,\n            type: 'string',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"mappings":"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","ignoreList":[]}