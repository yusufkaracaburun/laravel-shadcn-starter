{"version":3,"file":"alignTransform.cjs","names":["_commentParser","require","startsWithListMarker","text","isFirstLineOfTag","test","rewireSource","util","zeroWidth","name","start","tag","type","shouldAlign","tags","index","source","tokens","replace","includesTag","includes","iterator","previousTag","getWidth","width","Math","max","length","delimiter","getTypelessInfo","fields","hasNoTypes","every","maxNamedTagLength","map","filter","maxUnnamedTagLength","space","len","padStart","checkForListMarkers","hasListMarker","tagStartIndex","idx","isFirstLine","description","calculateListExtraIndent","firstContinuationIndent","postDelimiter","currentOriginalIndent","extraIndent","repeat","alignTransform","customSpacings","disableWrapIndent","indent","preserveMainDescriptionPostDelimiter","wrapIndent","intoTags","alignTokens","typelessInfo","nothingAfter","delim","postName","postType","postTag","untypedNameAdjustment","untypedTypeAdjustment","spacings","update","line","indentTag","isEmpty","end","postHyphenSpacing","postHyphen","hyphenSpacing","reduce","tagIndentMode","ret","_default","exports","default","module"],"sources":["../src/alignTransform.js"],"sourcesContent":["/**\n * Transform based on https://github.com/syavorsky/comment-parser/blob/master/src/transforms/align.ts\n *\n * It contains some customizations to align based on the tags, and some custom options.\n */\n\nimport {\n  // `comment-parser/primitives` export\n  util,\n} from 'comment-parser';\n\n/**\n * Detects if a line starts with a markdown list marker\n * Supports: -, *, numbered lists (1., 2., etc.)\n * This explicitly excludes hyphens that are part of JSDoc tag syntax\n * @param {string} text - The text to check\n * @param {boolean} isFirstLineOfTag - True if this is the first line (tag line)\n * @returns {boolean} - True if the text starts with a list marker\n */\nconst startsWithListMarker = (text, isFirstLineOfTag = false) => {\n  // On the first line of a tag, the hyphen is typically the JSDoc separator,\n  // not a list marker\n  if (isFirstLineOfTag) {\n    return false;\n  }\n\n  // Match lines that start with optional whitespace, then a list marker\n  // - or * followed by a space\n  // or a number followed by . or ) and a space\n  return /^\\s*(?:[\\-*]|\\d+(?:\\.|\\)))\\s+/v.test(text);\n};\n\n/**\n * @typedef {{\n *   hasNoTypes: boolean,\n *   maxNamedTagLength: import('./iterateJsdoc.js').Integer,\n *   maxUnnamedTagLength: import('./iterateJsdoc.js').Integer\n * }} TypelessInfo\n */\n\nconst {\n  rewireSource,\n} = util;\n\n/**\n * @typedef {{\n *   name: import('./iterateJsdoc.js').Integer,\n *   start: import('./iterateJsdoc.js').Integer,\n *   tag: import('./iterateJsdoc.js').Integer,\n *   type: import('./iterateJsdoc.js').Integer\n * }} Width\n */\n\n/** @type {Width} */\nconst zeroWidth = {\n  name: 0,\n  start: 0,\n  tag: 0,\n  type: 0,\n};\n\n/**\n * @param {string[]} tags\n * @param {import('./iterateJsdoc.js').Integer} index\n * @param {import('comment-parser').Line[]} source\n * @returns {boolean}\n */\nconst shouldAlign = (tags, index, source) => {\n  const tag = source[index].tokens.tag.replace('@', '');\n  const includesTag = tags.includes(tag);\n\n  if (includesTag) {\n    return true;\n  }\n\n  if (tag !== '') {\n    return false;\n  }\n\n  for (let iterator = index; iterator >= 0; iterator--) {\n    const previousTag = source[iterator].tokens.tag.replace('@', '');\n\n    if (previousTag !== '') {\n      if (tags.includes(previousTag)) {\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param {string[]} tags\n * @returns {(\n *   width: Width,\n *   line: {\n *     tokens: import('comment-parser').Tokens\n *   },\n *   index: import('./iterateJsdoc.js').Integer,\n *   source: import('comment-parser').Line[]\n * ) => Width}\n */\nconst getWidth = (tags) => {\n  return (width, {\n    tokens,\n  }, index, source) => {\n    if (!shouldAlign(tags, index, source)) {\n      return width;\n    }\n\n    return {\n      name: Math.max(width.name, tokens.name.length),\n      start: tokens.delimiter === '/**' ? tokens.start.length : width.start,\n      tag: Math.max(width.tag, tokens.tag.length),\n      type: Math.max(width.type, tokens.type.length),\n    };\n  };\n};\n\n/**\n * @param {{\n *   description: string;\n *   tags: import('comment-parser').Spec[];\n *   problems: import('comment-parser').Problem[];\n * }} fields\n * @returns {TypelessInfo}\n */\nconst getTypelessInfo = (fields) => {\n  const hasNoTypes = fields.tags.every(({\n    type,\n  }) => {\n    return !type;\n  });\n  const maxNamedTagLength = Math.max(...fields.tags.map(({\n    name,\n    tag,\n  }) => {\n    return name.length === 0 ? -1 : tag.length;\n  }).filter((length) => {\n    return length !== -1;\n  })) + 1;\n  const maxUnnamedTagLength = Math.max(...fields.tags.map(({\n    name,\n    tag,\n  }) => {\n    return name.length === 0 ? tag.length : -1;\n  }).filter((length) => {\n    return length !== -1;\n  })) + 1;\n  return {\n    hasNoTypes,\n    maxNamedTagLength,\n    maxUnnamedTagLength,\n  };\n};\n\n/**\n * @param {import('./iterateJsdoc.js').Integer} len\n * @returns {string}\n */\nconst space = (len) => {\n  return ''.padStart(len, ' ');\n};\n\n/**\n * Check if a tag or any of its lines contain list markers\n * @param {import('./iterateJsdoc.js').Integer} index - Current line index\n * @param {import('comment-parser').Line[]} source - All source lines\n * @returns {{hasListMarker: boolean, tagStartIndex: import('./iterateJsdoc.js').Integer}}\n */\nconst checkForListMarkers = (index, source) => {\n  let hasListMarker = false;\n  let tagStartIndex = index;\n  while (tagStartIndex > 0 && source[tagStartIndex].tokens.tag === '') {\n    tagStartIndex--;\n  }\n\n  for (let idx = tagStartIndex; idx <= index; idx++) {\n    const isFirstLine = (idx === tagStartIndex);\n    if (source[idx]?.tokens?.description && startsWithListMarker(source[idx].tokens.description, isFirstLine)) {\n      hasListMarker = true;\n      break;\n    }\n  }\n\n  return {\n    hasListMarker,\n    tagStartIndex,\n  };\n};\n\n/**\n * Calculate extra indentation for list items relative to the first continuation line\n * @param {import('./iterateJsdoc.js').Integer} index - Current line index\n * @param {import('./iterateJsdoc.js').Integer} tagStartIndex - Index of the tag line\n * @param {import('comment-parser').Line[]} source - All source lines\n * @returns {string} - Extra indentation spaces\n */\nconst calculateListExtraIndent = (index, tagStartIndex, source) => {\n  // Find the first continuation line to use as baseline\n  let firstContinuationIndent = null;\n  for (let idx = tagStartIndex + 1; idx < source.length; idx++) {\n    if (source[idx].tokens.description && !source[idx].tokens.tag) {\n      firstContinuationIndent = source[idx].tokens.postDelimiter.length;\n      break;\n    }\n  }\n\n  // Calculate the extra indentation of current line relative to the first continuation line\n  const currentOriginalIndent = source[index].tokens.postDelimiter.length;\n  const extraIndent = firstContinuationIndent !== null && currentOriginalIndent > firstContinuationIndent ?\n    ' '.repeat(currentOriginalIndent - firstContinuationIndent) :\n    '';\n\n  return extraIndent;\n};\n\n/**\n * @param {{\n *   customSpacings: import('../src/rules/checkLineAlignment.js').CustomSpacings,\n *   tags: string[],\n *   indent: string,\n *   preserveMainDescriptionPostDelimiter: boolean,\n *   wrapIndent: string,\n *   disableWrapIndent: boolean,\n * }} cfg\n * @returns {(\n *   block: import('comment-parser').Block\n * ) => import('comment-parser').Block}\n */\nconst alignTransform = ({\n  customSpacings,\n  disableWrapIndent,\n  indent,\n  preserveMainDescriptionPostDelimiter,\n  tags,\n  wrapIndent,\n}) => {\n  let intoTags = false;\n  /** @type {Width} */\n  let width;\n\n  /**\n   * @param {import('comment-parser').Tokens} tokens\n   * @param {TypelessInfo} typelessInfo\n   * @returns {import('comment-parser').Tokens}\n   */\n  const alignTokens = (tokens, typelessInfo) => {\n    const nothingAfter = {\n      delim: false,\n      name: false,\n      tag: false,\n      type: false,\n    };\n\n    if (tokens.description === '') {\n      nothingAfter.name = true;\n      tokens.postName = '';\n\n      if (tokens.name === '') {\n        nothingAfter.type = true;\n        tokens.postType = '';\n\n        if (tokens.type === '') {\n          nothingAfter.tag = true;\n          tokens.postTag = '';\n\n          /* c8 ignore next: Never happens because the !intoTags return. But it's here for consistency with the original align transform */\n          if (tokens.tag === '') {\n            nothingAfter.delim = true;\n          }\n        }\n      }\n    }\n\n    let untypedNameAdjustment = 0;\n    let untypedTypeAdjustment = 0;\n    if (typelessInfo.hasNoTypes) {\n      nothingAfter.tag = true;\n      tokens.postTag = '';\n      if (tokens.name === '') {\n        untypedNameAdjustment = typelessInfo.maxNamedTagLength - tokens.tag.length;\n      } else {\n        untypedNameAdjustment = typelessInfo.maxNamedTagLength > typelessInfo.maxUnnamedTagLength ? 0 :\n          Math.max(0, typelessInfo.maxUnnamedTagLength - (tokens.tag.length + tokens.name.length + 1));\n        untypedTypeAdjustment = typelessInfo.maxNamedTagLength - tokens.tag.length;\n      }\n    }\n\n    // Todo: Avoid fixing alignment of blocks with multiline wrapping of type\n    if (tokens.tag === '' && tokens.type) {\n      return tokens;\n    }\n\n    const spacings = {\n      postDelimiter: customSpacings?.postDelimiter || 1,\n      postName: customSpacings?.postName || 1,\n      postTag: customSpacings?.postTag || 1,\n      postType: customSpacings?.postType || 1,\n    };\n\n    tokens.postDelimiter = nothingAfter.delim ? '' : space(spacings.postDelimiter);\n\n    if (!nothingAfter.tag) {\n      tokens.postTag = space(width.tag - tokens.tag.length + spacings.postTag);\n    }\n\n    if (!nothingAfter.type) {\n      tokens.postType = space(width.type - tokens.type.length + spacings.postType + untypedTypeAdjustment);\n    }\n\n    if (!nothingAfter.name) {\n      // If post name is empty for all lines (name width 0), don't add post name spacing.\n      tokens.postName = width.name === 0 ? '' : space(width.name - tokens.name.length + spacings.postName + untypedNameAdjustment);\n    }\n\n    return tokens;\n  };\n\n  /**\n   * @param {import('comment-parser').Line} line\n   * @param {import('./iterateJsdoc.js').Integer} index\n   * @param {import('comment-parser').Line[]} source\n   * @param {TypelessInfo} typelessInfo\n   * @param {string|false} indentTag\n   * @returns {import('comment-parser').Line}\n   */\n  const update = (line, index, source, typelessInfo, indentTag) => {\n    /** @type {import('comment-parser').Tokens} */\n    const tokens = {\n      ...line.tokens,\n    };\n\n    if (tokens.tag !== '') {\n      intoTags = true;\n    }\n\n    const isEmpty =\n      tokens.tag === '' &&\n      tokens.name === '' &&\n      tokens.type === '' &&\n      tokens.description === '';\n\n    // dangling '*/'\n    if (tokens.end === '*/' && isEmpty) {\n      tokens.start = indent + ' ';\n\n      return {\n        ...line,\n        tokens,\n      };\n    }\n\n    switch (tokens.delimiter) {\n      case '*':\n        tokens.start = indent + ' ';\n        break;\n      case '/**':\n        tokens.start = indent;\n        break;\n      default:\n        tokens.delimiter = '';\n\n        // compensate delimiter\n        tokens.start = indent + '  ';\n    }\n\n    if (!intoTags) {\n      if (tokens.description === '') {\n        tokens.postDelimiter = '';\n      } else if (!preserveMainDescriptionPostDelimiter) {\n        tokens.postDelimiter = ' ';\n      }\n\n      return {\n        ...line,\n        tokens,\n      };\n    }\n\n    const postHyphenSpacing = customSpacings?.postHyphen ?? 1;\n    const hyphenSpacing = /^\\s*-\\s+/v;\n    tokens.description = tokens.description.replace(\n      hyphenSpacing, '-' + ''.padStart(postHyphenSpacing, ' '),\n    );\n\n    // Not align.\n    if (shouldAlign(tags, index, source)) {\n      alignTokens(tokens, typelessInfo);\n\n      if (!disableWrapIndent && indentTag) {\n        const {\n          hasListMarker,\n          tagStartIndex,\n        } = checkForListMarkers(index, source);\n\n        if (hasListMarker && index > tagStartIndex) {\n          const extraIndent = calculateListExtraIndent(index, tagStartIndex, source);\n          tokens.postDelimiter += wrapIndent + extraIndent;\n        } else {\n          // Normal case: add wrapIndent after the aligned delimiter\n          tokens.postDelimiter += wrapIndent;\n        }\n      }\n    }\n\n    return {\n      ...line,\n      tokens,\n    };\n  };\n\n  return ({\n    source,\n    ...fields\n  }) => {\n    width = source.reduce(getWidth(tags), {\n      ...zeroWidth,\n    });\n\n    const typelessInfo = getTypelessInfo(fields);\n\n    let tagIndentMode = false;\n\n    return rewireSource({\n      ...fields,\n      source: source.map((line, index) => {\n        const indentTag = !disableWrapIndent && tagIndentMode && !line.tokens.tag && line.tokens.description;\n        const ret = update(line, index, source, typelessInfo, indentTag);\n\n        if (!disableWrapIndent && line.tokens.tag) {\n          tagIndentMode = true;\n        }\n\n        return ret;\n      }),\n    });\n  };\n};\n\nexport default alignTransform;\n"],"mappings":"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","ignoreList":[]}