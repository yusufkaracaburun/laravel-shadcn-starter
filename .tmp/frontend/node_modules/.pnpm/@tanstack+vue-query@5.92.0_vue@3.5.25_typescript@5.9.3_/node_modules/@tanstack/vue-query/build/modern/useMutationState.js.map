{"version":3,"sources":["../../src/useMutationState.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  shallowReadonly,\n  shallowRef,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  MutationFilters as MF,\n  Mutation,\n  MutationState,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { MaybeRefDeep } from './types'\nimport type { MutationCache } from './mutationCache'\n\nexport type MutationFilters = MaybeRefDeep<MF>\n\nexport function useIsMutating(\n  filters: MutationFilters | (() => MutationFilters) = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const mutationState = useMutationState(\n    {\n      filters: computed(() => ({\n        ...cloneDeepUnref(typeof filters === 'function' ? filters() : filters),\n        status: 'pending' as const,\n      })),\n    },\n    client,\n  )\n  const length = computed(() => mutationState.value.length)\n\n  return length\n}\n\nexport type MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (mutation: Mutation) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select ? options.select(mutation) : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options:\n    | MutationStateOptions<TResult>\n    | (() => MutationStateOptions<TResult>) = {},\n  queryClient?: QueryClient,\n): Readonly<Ref<Array<TResult>>> {\n  const resolvedOptions = computed(() => {\n    const newOptions = typeof options === 'function' ? options() : options\n    return {\n      filters: cloneDeepUnref(newOptions.filters),\n      select: newOptions.select,\n    }\n  })\n  const mutationCache = (queryClient || useQueryClient()).getMutationCache()\n  const state = shallowRef(getResult(mutationCache, resolvedOptions.value))\n  const unsubscribe = mutationCache.subscribe(() => {\n    state.value = getResult(mutationCache, resolvedOptions.value)\n  })\n\n  watch(resolvedOptions, () => {\n    state.value = getResult(mutationCache, resolvedOptions.value)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return shallowReadonly(state)\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAaxB,SAAS,cACd,UAAqD,CAAC,GACtD,aACa;AACb,MAAI,QAAQ,IAAI,aAAa,eAAe;AAC1C,QAAI,CAAC,gBAAgB,GAAG;AACtB,cAAQ;AAAA,QACN;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,eAAe,eAAe;AAE7C,QAAM,gBAAgB;AAAA,IACpB;AAAA,MACE,SAAS,SAAS,OAAO;AAAA,QACvB,GAAG,eAAe,OAAO,YAAY,aAAa,QAAQ,IAAI,OAAO;AAAA,QACrE,QAAQ;AAAA,MACV,EAAE;AAAA,IACJ;AAAA,IACA;AAAA,EACF;AACA,QAAM,SAAS,SAAS,MAAM,cAAc,MAAM,MAAM;AAExD,SAAO;AACT;AAOA,SAAS,UACP,eACA,SACgB;AAChB,SAAO,cACJ,QAAQ,QAAQ,OAAO,EACvB;AAAA,IACC,CAAC,aACE,QAAQ,SAAS,QAAQ,OAAO,QAAQ,IAAI,SAAS;AAAA,EAC1D;AACJ;AAEO,SAAS,iBACd,UAE4C,CAAC,GAC7C,aAC+B;AAC/B,QAAM,kBAAkB,SAAS,MAAM;AACrC,UAAM,aAAa,OAAO,YAAY,aAAa,QAAQ,IAAI;AAC/D,WAAO;AAAA,MACL,SAAS,eAAe,WAAW,OAAO;AAAA,MAC1C,QAAQ,WAAW;AAAA,IACrB;AAAA,EACF,CAAC;AACD,QAAM,iBAAiB,eAAe,eAAe,GAAG,iBAAiB;AACzE,QAAM,QAAQ,WAAW,UAAU,eAAe,gBAAgB,KAAK,CAAC;AACxE,QAAM,cAAc,cAAc,UAAU,MAAM;AAChD,UAAM,QAAQ,UAAU,eAAe,gBAAgB,KAAK;AAAA,EAC9D,CAAC;AAED,QAAM,iBAAiB,MAAM;AAC3B,UAAM,QAAQ,UAAU,eAAe,gBAAgB,KAAK;AAAA,EAC9D,CAAC;AAED,iBAAe,MAAM;AACnB,gBAAY;AAAA,EACd,CAAC;AAED,SAAO,gBAAgB,KAAK;AAC9B;","names":[]}